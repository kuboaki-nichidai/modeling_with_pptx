:linkcss:
:stylesdir: css
:stylesheet: mystyle.css
:twoinches: width='360'
:full-width: width='100%'
:three-quarters-width: width='75%'
:two-thirds-width: width='66%'
:half-width: width='50%'
:half-size:
:one-thirds-width: width='33%'
:one-quarters-width: width='25%'
:thumbnail: width='60'
:imagesdir: images
:sourcesdir: codes
:icons: font
:hide-uri-scheme!:
:figure-caption: 図
:example-caption: リスト
:table-caption: 表
:appendix-caption: 付録
:xrefstyle: short
:section-refsig:
:chapter-refsig:
:sectnums:

:toc:


= PowerPointを使ったモデリング演習

[.lead]
この演習では、UMLを使うようなモデリング演習を、PowerPointを簡便な作図ツールとして使って実施します。

== この演習のポイント

.モデルとコードを結びつける技術が大事（ <<model_to_code>> ）
--
* モデリング
* プログラミング
* **これらを結びつける技術**
--

[[model_to_code]]
.モデルとコードを結びつける技術
image::model_to_code.png[{full-width}]

== 【演習1】コードの構造をモデル図で表そう


=== 誰が何をするコードだろう？

<<sample01>> が、誰が何をするコードなのかわかりますか。

[NOTE]
--
SWEST参加者なら、これがEV3RTのコードだとわかるでしょう。 +
main_task(...)は、main関数のようなものと思ってください。 +
この関数の終わりでは、ext_tskを呼ぶ決まりです。
--

[[sample01]]
.【C】 `sample01/app.c`
[example]
--
[source, c, linenums]
----
void main_task(intptr_t unused) {
  init_f("sample01"); 
  ev3_motor_config(EV3_PORT_A, LARGE_MOTOR);
  ev3_motor_config(EV3_PORT_C, LARGE_MOTOR);
  ev3_sensor_config(EV3_PORT_1, TOUCH_SENSOR);

  ev3_motor_set_power(EV3_PORT_A, 40);
  ev3_motor_set_power(EV3_PORT_C, 40);

  while(!ev3_touch_sensor_is_pressed(EV3_PORT_1));

  ev3_motor_set_power(EV3_PORT_A, -40);
  ev3_motor_set_power(EV3_PORT_C, -40);

  tslp_tsk(2000); 

  ev3_motor_stop(EV3_PORT_A, false);
  ev3_motor_stop(EV3_PORT_C, false);

  ext_tsk();
}
----
--


=== 「モノ」と「働き」を抜き出してみよう

==== 準備

演習用のワークブックとして、このリポジトリにある `workbook.pptx` を使います。
PowerPointで `workbook.pptx` を開き、その中に演習の成果を書き込んでいきましょう。

Webブラウザで、 `README.adoc` を

==== 作業手順

. ワークブックの3ページ（「モノ」と「働き」の抜き書き）を開きます
. <<sample01>>から「モノ」を表すことばを見つけ出します
. 「モノ」のシンボルを複製して、その名前を書きます
. <<sample01>>から「働き」を表すことばを見つけ出します
. 「働き」のシンボルを複製して、その名前を書きます

[width="50%"]
|===
a|image::mono_symbol.png[{full-width}] a|image::hataraki_symbol.png[{full-width}]
|===

[TIP]
--
ワークブックの3ページに示すように、この演習では「OS」は「モノ」としておきます。
またRTOSのタスクの実態は関数ですが、ここでは「MainTask」が「main_task」関数を働きとしてもつ「モノ」tお捉えておきます。
--

==== 結果を図に保存する

抜き書きできたら、いったん図に保存します。

. 3ページに描画したすべての図形を選択します
. 選択した状態で、右クリックしてポップアップメニューを開きます
. 「図に保存」を選びます
. このリポジトリの `images` ディレクトリにある `nukigaki.png` ファイルを置き換えて保存します
. <<nukigaki>> が、作成した図に置き換わります

[[nukigaki]]
.「モノ」と「働き」の抜き書き
image::nukigaki.png[{full-width}]

[NOTE]
--
図が置き換わったら、一度コミットしておきましょう。
--

=== 「モノ」に「働き」を寄せる

==== 作業手順

. ワークブックの4ページをみて、「モノに働きを寄せる」操作を確認します
. ワークブックの5ページに、<<nukigaki>>から「モノ」と「働き」をコピーします
. 「モノ」をひとつ選んで、そのモノの働きを探して、ちょっと重ねてひとかたまりにします
. すべての「モノ」について「働き」を検討します
** なかには「働き」の見つからない「モノ」や寄せる「モノ」が見つからない「働き」もあるでしょう

==== 結果を図に保存する

寄せる作業ができたら、いったん図に保存します。

. 5ページに描画したすべての図形を選択します
. 選択した状態で、右クリックしてポップアップメニューを開きます
. 「図に保存」を選びます
. このリポジトリの `images` ディレクトリにある `yoseyose.png` ファイルを置き換えて保存します
. <<yoseyose>> が、作成した図に置き換わります

[[yoseyose]]
.「モノ」に「働き」を寄せた
image::yoseyose.png[{full-width}]

[NOTE]
--
図が置き換わったら、一度コミットしておきましょう。
--

=== 「モノ」同士を関連づけてクラス図にする

==== 作業手順

. ワークブックの6ページをみて、「モノ同士を関連づける」操作を確認します
. ワークブックの7ページに、<<yoseyose>>から「モノ」と「働き」のかたまりをコピーします
. 「モノ」から「モノ」へのつながりを探して、関連の線を引きます
. すべての「モノ」について関連を検討します
** なかには他との関連が見つからない「モノ」もあるでしょう。

==== 結果を図に保存する

関連づけ作業ができたら、いったん図に保存します。

. 7ページに描画したすべての図形を選択します
. 選択した状態で、右クリックしてポップアップメニューを開きます
. 「図に保存」を選びます
. このリポジトリの `images` ディレクトリにある `class01.png` ファイルを置き換えて保存します
. <<class01>> が、作成した図に置き換わります

[[class01]]
.「モノ」同士を関連づけてクラス図にした
image::class01.png[{full-width}]

[NOTE]
--
図が置き換わったら、一度コミットしておきましょう。
--


=== プログラムの動作を確認する


プログラムを動かして、どんなプログラム確認してみましょう。

==== 動かす対象の機器

対象の機器は、LEGO Mindstorms EV3のキットで作った、バンパーや荷台のある自動搬送ロボットでした（ <<autotransporter_view>> ）。

[[autotransporter_view]]
.Mindstorms EV3のキットで作った自動搬送ロボット
image::transporter_ev3.png[{three-quarters-width}]


==== プログラムを動かす

このプログラムを動かしてみましょう。


[[sample01_mp4]]
.sample01の動画
video::vdqQvXNUl2k[youtube, start=34, options=autoplay]


[NOTE]
--
ここでは、LEGO Mindstorms EV3やそのキットの説明は省きます。
--

このプログラムは、「前進して…壁にぶつかると、２秒後退して止まり」ました。

==== 動作とコードを比較する

もう一度コードを見てみましょう。


[[sample01_re]]
.【C】 `sample01/app.c`（再掲）
[example]
--
[source, c, linenums]
----
void main_task(intptr_t unused) {
  init_f("sample01"); 
  ev3_motor_config(EV3_PORT_A, LARGE_MOTOR); // <1>
  ev3_motor_config(EV3_PORT_C, LARGE_MOTOR);
  ev3_sensor_config(EV3_PORT_1, TOUCH_SENSOR);

  ev3_motor_set_power(EV3_PORT_A, 40); // <2>
  ev3_motor_set_power(EV3_PORT_C, 40);

  while(!ev3_touch_sensor_is_pressed(EV3_PORT_1)); // <3>

  ev3_motor_set_power(EV3_PORT_A, -40); // <4>
  ev3_motor_set_power(EV3_PORT_C, -40);

  tslp_tsk(2000); // <5>

  ev3_motor_stop(EV3_PORT_A, false); // <6>
  ev3_motor_stop(EV3_PORT_C, false);

  ext_tsk();
}
----
<1> センサーやモーターのポート設定
<2> 左右輪のモーターで前進を開始
<3> 壁にぶつかるのを待っている
<4> 後退している
<5> 2秒待っている（モーターは回り続けている）
<6> 停止する
--


=== どんな問題があるだろうか？

==== コードをみてやっていることがわかりますか？

* 「荷物を運ぶ」
* 「前進して壁にぶつかると２秒後退して止まる」
* 「走行する」とか、「前進する」とか、「壁にぶつかるまで」って書いてありましたっけ？

==== sample01は動作するみたいだけど、問題がありそう

* コードを読んでも、何がやりたいのかわかりません
* コードとロボットの動作の対応がわかりません
* ロボットの構造とコードの意味を知っている人だけしか理解できないでしょう

==== もう一度クラス図を見てみよう

[[class01_re]]
.「モノ」同士を関連づけてクラス図にした（再掲）
image::class01.png[{full-width}]

* 「荷物を運搬する」とわかりますか
* 「走行する」プログラムとわかりますか
* 「前進する」などロボットの働きを指示していますか


=== 演習1のまとめ

* コードの構造と図の要素を対応づけしました
** 対応づけすることで図に表すことができました

* なにが問題でしょう？
** コードはもともとあった情報が失われていませんか
** ロボットのどの部分が動くのかわかりません
**どんな動作が起こるかわかりません

* それは誰の問題でしょうか？
** 失われた情報はプログラマが頭の中で漉してしまった…
「そういう風に動くには、こう書いとけばいいな…」みたいな


== 途中省略

他の既存プログラムに対しても同様の検討を進めた結果、自動搬送ロボットのクラス図では、業務やロボットのことばが使われるようになりました（ <<autotransporter04>> ）。

[[autotransporter04]]
.検討が進んだ自動搬送ロボットのクラス図
image::autotransporter04.png[{full-width}]

また、階層化アーキテクチャも発見できました。


== 【演習4】運搬業務の振舞いをモデルで表す


=== 自動搬送ロボットの業務


==== 業務の概要

* 自動搬送ロボットは、荷物を運んで配達先まで走行し、その後車庫に入る

==== 運搬業務の詳細

[[transporter_desc]]
.自動搬送ロボットの業務の詳細
. 自動搬送ロボットは、待機場所で待機している
. 自動搬送ロボットは、荷物を受け取る（載せられる）と、運搬を開始する
. 自動搬送ロボットは、経路に沿って運搬する
. 自動搬送ロボットは、配達先の側壁を検知すると、停止する
. 自動搬送ロボットは、荷物を引き渡す（下ろされる）と、回送を開始する
. 自動搬送ロボットは、経路に沿って回送する
. 自動搬送ロボットは、車庫の正面の壁を検知すると、停止する

図で表すと、「 <<transporter_work>> 」のようになります。

[[transporter_work]]
.自動搬送ロボットの業務の図
image::transporter_work.png[{full-width}]

この手順を、どのように設計書に表し、コードに表せばよいでしょうか？

=== 振舞いを表すモデル

クラス図は、構成要素とその関係を使って構造を表すモデルでした。
処理の順序を示したり、あるできごとが起きたときにどんな処理をするのかといったことを説明するのには向いていません。

そこで、別途振舞いを表すモデルを使います。

==== 振舞いのモデルの種類

システムやコードの動き方を説明するモデルです。
どのような動きに関心があるのかに応じて、いくつかの図があります。

.振舞いのモデルの種類
* ステートマシン図（状態遷移図・状態遷移表）
* シーケンス図
* アクティビティ図
* など

この演習では、ステートマシン図を使ってみましょう。

.ステートマシン図の特徴
* 状態とイベントに着目して振舞いを整理する図です
* できごと（イベント）を待っている場所を「状態」と捉えます
* イベントが発生（発火）したときに実行する処理が「アクション」です
* イベントが発生すると、次のイベントを松城たへ「状態遷移」します


==== 状態の候補を見つけるコツ

. 自分では起こせない事象を待つところ
** 外部からの操作や受信の待ち
** 時間の経過待ち（タイムアウト）

. 同じできごとが起きた時に処理が異なる状況
** 停止中や再生中における早送りボタン
** 温め中とそうでない時の電子レンジのドアの開閉

=== Porterクラスの振舞いを洗い出そう

==== 作業手順

. ワークブックの9ページをみて、「ステートマシン図の要素と描き方」を確認します
. ワークブックの10ページに「状態」を2つ間を空けて置きます
. 2つの状態の間に「状態遷移」を引き「イベント」を置きます
. <<transporter_desc>> や <<transporter_work>> を見ながら、起きるのを待っているできごとを調べます
. 見つけたできごとを「イベント」に書きます
. イベントが起きたときに実行したいことを「アクション」に書き、状態遷移先の状態に重ねて
. すべてのできごとについて同じ手順を繰り返します
. 最初の状態には黒丸から矢印を、最後の状態（何もできごとを待っていない状態）からは二重黒丸へ矢印を引きます

==== 結果を図に保存する

イベントと状態とアクションが洗い出せたら、いったん図に保存します。

. 10ページに描画したすべての図形を選択します
. 選択した状態で、右クリックしてポップアップメニューを開きます
. 「図に保存」を選びます
. このリポジトリの `images` ディレクトリにある `stm01.png` ファイルを置き換えて保存します
. <<stm01>> が、作成した図に置き換わります

[[stm01]]
.振舞いを洗い出してステートマシン図にした
image::stm01.png[{full-width}]

[NOTE]
--
図が置き換わったら、一度コミットしておきましょう。
--

[NOTE]
--
演習したステートマシン図の例が、 `images` ディレクトリの `stm02.png` にあります。
--

=== 演習4のまとめ

* 振舞いのモデル（ステートマシン図）を紹介しました
** 振舞いは、状態、イベント、状態遷移、アクションの組み合わせで記述できることがわかりました
** とくに状態の認識の重要さを考えました

* 課題の振舞いを、ステートマシン図で設計しました
** 課題の処理は、状態やイベントで表せることがわかりました
** 仕様の変更や振舞いの追加に対応するのも、図で考えたほうが分かりやすいことがわかりました


== 以降省略

実装では、コードを作成するルールを決めます。

* クラス図やクラス、関連をどのようにコードに変換するか
* ステートマシン図の状態遷移のしくみの実装方法
* イベント、アクション、状態をどのようにコードに変換するか

そして、コードと動作を確認します。

* できあがったコードが、元のモデルのことばを使って書かれているか


追加課題にも対応した最終的なモデルからできたコードの動作を確認します。


[[sample04_mp4]]
.sample04の動画
video::-vaPDf_4p_k[youtube, start=34, options=autoplay]



